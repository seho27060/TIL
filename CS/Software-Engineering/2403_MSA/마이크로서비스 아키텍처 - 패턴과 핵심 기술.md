[TOC]

# 마이크로서비스 아키텍쳐 : 패턴과 핵심 기술, MSA(MicroService Architecture)

- udemy 강의 참고

## Section_00

### Section Detail

#### index1

##### detail-index1

## Section 01. MSA 소개

### MSA의 등장 배경

- 점차 크기가 증가하는 모놀리식 서비스의 한계
  
  - 배포시 마다의 부하 증가
  
  - 몸집이 커지는 서비스의 복잡함을 예측할 수 없음

- 각 도메인 별로 여러 분리된 서비스(seperated serviecies)의 결합

## Section 02. MSA 개념과 주요 특징

### MSA 소개 : 전통적 개발 방법론 및 Monolithic 소개

- 전통적으로 전체 기능을 단일 코드베이스로 개발

- 대규모로 단일 코드베이스로 구성된 서비스의 빌드/배포

#### Monolithic System 장점과 단점

##### 단점

- scale out 시 전체 시스템을 확장해야 하는 비효율
  
  - == 필요한 부분(기능)만 scale out이 안됨

- 빌드/배포 시간의 비효율적 소모

- 작은 수정에도 전체 시스템 빌드/배포
  
  - 시스템자체가 크다보니...부하가 매우 큼

- 서비스 자체 내부에서 결합도가 매우 커 기능간 의존관계가 매우 큼
  
  - 유지보수간 수정에 복잡도 증가

- 결국 민첩한(agile) 배포가 불가함.

##### 장점

- 상대적으로 운영에 용이함

- 트랜잭션 관리가 쉬움

#### Monolithic System의 종류

- Single Monolithic System
  
  - 가장 일반적인 형태

- Modular Monolith
  
  - 모듈화된 구성
  
  - MSA의 좋은 대안(된다면)
  
  - 모듈간 결합도 검증을 주기적으로 점검해야함

- Distributed Monolithic System
  
  - 분산된 Monolith
  
  - 코드베이스가 분리되었지만, MSA가 아님
    
    - 코드베이스가 분리되었지만, 서로간 결합이 강하여 자율적 빌드/배포가 불가한 상황

#### Always truths

- 상황과 자원에 적합한 대안이 존재하는 것이지, 항상 맞는 정답은 없다.  

### MSA 개념, 장점, 단점

- MicroService Architecture
  
  - 애플리케이션을 자율적인 다수의 서비스로 분리 개발
  
  - 분리된 서비스는 HTTP와 같은 네트워크를 통해 통신
  
  - 분리된 서비스는 자율적 빌드/배포 가능

- MSA의 부각 이유 
  
  - 요구사항의 빠른 반영 필요
  
  - 다양한 영역에서의 IT 기술 적용
  
  - Cloud, Docker, k8s, Netflix OSS 와 같은 기술적 지원의 증가

#### 장점

- 빠른 Delivery
  
  - 각 서비스들의 독립적 개발, (네트워크 통신에 의한) 느슨한 결합

- 탄력적, 선택적 확장
  
  - 필요한 부분의 서비스만 수정
  
  - 확장 역시 필요부분에 한정되므로 비용 감소

- Polyglot Architecture 지원
  
  - 서비스별 적절한 기술(프로그래밍 언어, 프레임워크 등) 선택 가능

- 실험과 혁신 가능성
  
  - 기술의 혁신이 필수적인 급변하는 비즈니스 시장에서 기술 시험 또는 기술 부채 해결에 용이함

- 대체 가능성
  
  - 기존 서비스에 사용된 언어/프레임워크를 새롭게 개발 가능
  
  - 서비스간 결합도가 낮으므로 용이함
  
  - 3-4명의 개발자가 2주만에 개발할 수 있는게 적절한 사이즈(정답은 없다)

- 기술 부채 경감
  
  - 기술적 변경/교체 가능성이 높아 기술 부채 해결에 용이함

#### 단점

- 컴퓨팅 자원의 비효율성

- 운영관리의 어려움(모니터링 대상 증가)

- 좀 더 다양하고 복잡한 장애 상황 발생

- 단위 테스트 컴포넌트 테스트 난이도 증가

- DB 트랜잭션 처리 어려움
  
  - 분산환경에서의 트랜잭션 난이도 증가

### MSA 주요 특징

- 서비스 기반 컴포넌트화

- 분산된 거버넌스/ 데이터 관리

#### 서비스를 통한 컴포넌트화

- MSA에선 서비스 단위를 컴포넌트로 정의
  
  - 특정 비즈니스 기능 담당
  
  - 독립적 프로세스

#### 비즈니스 역량에 따른 조직 구성

- Conway의 법칙 : 시스템을 설계하는 조직은 그 조직의 소통 구조를 닮은 아키텍쳐를 만든다

- 전톻적인 기술에 따른 조직 구성(DB, BE, FE등 기술로만 이뤄진 팀으로 조직이 구성)

- 서비스에 따른 조직 구성(1개 서비스를 위한 여러 역량을 팀 내부에서 갖춤)

- 개발부터 운영까지 이어지는..devOps

#### 분산된 거버넌스/ 데이터 관리

- 중앙에 강력한 표준, 절차 준수가 강요되지 않음

- 스스로 효율적인 방법론과 도구, 기술을 찾아 적용

- 단일 통합 데이터베이스가 아닌, 서로 각각의 데이터베이스를 갖음

- 다른 서비스 데이터를 접근시에는 API를 활용함

#### 인프라 자동화

- 다수의 서비스, 인스턴스가 운영되므로 인프라 자동화가 필수적

#### 장애 방지 설계

- MSA의 경우 특정 서비스의 장애가 전체 서비스 장애로 전파될 수 있음

- 서비스의 이상 동작 감지에 민감해야 함

- 가능하다면 "자동 복구"가 가능하도록 설계되야함.

## Section 03. MSA 도입을 위한 역량 및 필요조건

### MSA 도입 조건

- 사업/ 조직적 측면
  
  - MSA가 중장기적 business benefit을 올릴 수 있는가?
  
  - 고위 경영진의 확고한 의지
  
  - MSA 전환은 코드뿐만 아닌 조직과 프로세스의 개선 작업 필

- 기술적 측면
  
  - Rapid Provisioning : 클라우드 환경, Docker/K8s를 통한 인프라 자동화
  
  - 정교한 Monitoring 및 장애관리
  
  - 자동화 된 배포

- MSA 도입 시기
  
  - MSA 도입 비용이 크다는 점 인식
  
  - Monolith의 단점들이 Business에 부정적 영향이 너무 클 때

- 던져봐야 할 질문
  
  - SW 관련 현재 조직의 문제 및 목표는 무엇?
    
    - 단순 신기술이라는 이유로 도입하는건 아니지
  
  - MSA가 현재 조직의 문제와 목표를 해결해줄 수 있는가?
  
  - 

### MSA 역량 모델 Part 1

#### MSA 서비스 역량 모델

- 획일화된 모델이 없음

#### 역량 분류

- 핵심 역량 - 서비스 별 배포되는 SW 패키지 필수 요소
  
  - 서비스 Listener - HTTP 등 Listener가 애플리케이션에 내장 되어야함
    
    - Spring => SpringBoot 와 같은 자체 내장 Endpoint 
  
  - Endpoint - Application
  
  - 서비스 구현 - 단일 책임 원칙을 지키는 높은 응집도
    
    - Hexagonal Architecture : 외부 시스템(인프라, DB)가 무엇이든 간에 비즈니스 핵심 로직은 영향받지 않아야 한다.
  
  - 데이터 저장(DB) - 데이터소스는 하나의 서비스에 한정되야 한다.[]()

- 지원 역량 - 지원 기술 및 설계 패턴

- 인프라 역량 - 컨테이너 및 컨테이너 오케스트레이션
  
  - 클라우드 - On Demand로 적은 공수로 리소스 프로비저닝 가능
  
  - 컨테이너 런타임 - Docker를 통한 컨테이너 구성
  
  - 컨테이너 오케스트레이션 - 많은 수의 컨테이너 관리 역량
    
    - 배포, 모니터링 등 운영 관리 비용 최소

- 프로세스 및 통제 역량 - DevOps 및 문서화 등

### MSA 역량 모델 Part 2

#### 지원 역량

##### Service Discovery

- MSA 도입 시 서비스 개수 및 인스턴스 개수 급증

- 어떤 서비스가 다른 서비스의 물리적인 정보(ip, port)들을 유지하는 건 비효율적

- 따라서 중앙에서 시스템의 모든 서비스에 대한 정보를 유지하여 서비스들은 다른 서비스를 호출시 필요한 정보를 중앙에서부터 불러와 사용함
  
  - 서비스의 정보가 변경되어도 중앙에서 관리되므로 MSA에서의 많은 변경에도 문제없이 호출 가능하도록 한다.

##### Config Server

- 모놀리식에서는 설정 정보를 자체 설정 파일이나 OS 환경변수로 관리

- MSA에서는 설정 관리가 복잡해진다
  
  - 20개 서비스 \* 5개 환경 => 100개 설정 파일 필요

- 환경마다 새롭게 빌드/패키징
  
  - 서비스 100개면 100개 모두 재배포 필요

- 설정 정보를 Application 파일에서 완전히 분리한다.
  
  - 중앙 Config Server에서는 설정 관리한다.
  
  - 서비스는 Application 실행시 중앙서버에서 Config 불러와 사용

##### API Gateway

- 다양한 서비스들에 대한 단일 진입 점

- 인증, 인가, 로깅, 필터링 등 공통 처리 수행

- 다양한 요청을 받아 분류하여 각각의 서비스에 전달

##### SW Defined Load Balancer

- MSA에서는 인프라 토폴로지가 매우 복잡하여 전동적 로드밸런서는 사용이 비효율적

- 서비스를 호출하는 클라이언트에서 SW로 로드밸런싱을 하는 방법
  
  - 클라이언트(서비스 A)에서 내재된 SW가 로드밸런

##### Circuit Breaker

- 서비스의 장애를 대응 가능한 장애 방지 설계

- MSA에서는 1개 서비스 장애가 전체로 이어질 수 있다

- 특정 서비스의 장애는 해당 서비스의 장애로만 격리되어야만 한다.
  
  - 서비스간 서킷브레이커가 서비스간 장애 발생을 판단하여 Circuit을 차단한다.

##### Distributed Tracing

- 분산 추적

- 한개 API 호출 시 다양한 서비스에 분산되어 에러 추적이 어렵다

- 서비스간 모든 호출에 추적 ID를 삽입하여 단일 API 트랜잭션의 활동을 파악

##### Data Lake

- MSA에서는 데이터 파편화 가능성이 존재한다.

- 비정형 원시 데이터를 그대로 저장
  
  - Hadoop, HDFS와 같은 대용량 처리 기술 활용
  
  - 데이터 분석이 필요시에 데이터 가공에 대한 고민

- 전통적 ETL이 아닌 실시간 Data Ingestion 활용
  
  - ELK

##### Messaging

- MSA는 메시징을 이용한 서비스 간 협력 설계 방식 권고

- 메시징(이벤트) 주도 설계는 서비스 간 결합도를 낮출 수 있다

- 고가용성 메시징 솔루션 활용
  
  - RabbitMQ, Kafka

#### 프로세스 및 통제 역량

##### DevOps

- 애자일과 같이 DevOps는 MSA 성공을 위한 필수 요소

- 자동화된 CI/CD, QA

- DevOps 조직 구성되어 한 팀에서 개발, 배포, 운영, 모니터링이 되어야 함

##### 자동화 도구

- 다양한 형태의 다수 서비스를 테스트, 배포, 운영해야 하므로 자동화할 수 있는건 해야한다.

##### 컨테이너 레지스트리

- MSA에서 필수적인 컨테이너 사용

- 컨테이너 핵심인 이미지 관리
  
  - Docker Hub, GCR,...

##### 문서화

- 빠른 변화에 대응하는 인터페이싱 제공 문서

- 웹으로 열람 가능해야함
  
  - REST Docs, Swagger 

##### 참조 아키텍처 및 라이브러리

- 탈중앙화된 MSA는 비효율성을 야기할 수 있다.
  
  - 서로 다른 아키텍처로 인한 유지 보수성 약화

- 조직의 기술 별 참조 모델 중요
  
  - 참조 아키텍처는 프레임워크화
  
  - 또는 사용 기술(버전, 도구)의 통일

### MSA 성숙도 모델

- 조직의 성숙도 상태 진단

- 현재 우리의 단계는 어디인가 판단하는 모델
  
  - 다음 단계로 무엇을 해야하는지 가이드

- MSA의 표준 성숙도 모델은 없지만 두개의 모델 제안
  
  - Rajesh RV
  
  - Rishi Singh

#### Rajesh RV 제안 성숙도 모델

- Level 0(모놀리식) \~ Level 3(API 중심)으로 구성됨

#### Rishi Singh 제안 성숙도 모델

- 총 9가지 영역에서 4단계의 성숙도 모델 제안
  
  - 4단계 성숙도 : Early, Inception, Expanding, Mature
  
  - Expading은 현실적 MSA => Mature는 이상적 MSA로 보면된다

##### 기능적 분할 영역

- Early : Business 역량에 따른 기능 분할

- Inception : Modular Monolith, 서비스간 명확한 Interface

- Expanding : 도메인 주도 설계에 의한 잘 분할 된 서비스

- Mature : 이벤트 기반의 협력, 조회와 명령의 분할

##### Data 영역

- Early : 서비스 간 저장소 공유, ACID 기반 Transaction

- Inception : 일부 새로운 서비스들에 대한 독립 저장소

- Expanding : 모든 서비스들의 독립 저장소, Polyglot Persistence, Eventual Consistency

- Mature : Event 기반 데이터 관리, Event Sourcing, CQRS

##### Testing 영역

- Early : 수동/자동 Testing 혼재

- Inception : 완전 자동화 된 Testing 수행

- Expanding : Chaos Engineering

- Mature : Consumer Driven Contract, 고객 페르소나 기반 E2E Testing

##### Infrastructure 영역

- Early : CI/Build

- Inception : CD, 중앙 집중형 Logging

- Expanding : Container/Orchestration

- Mature : 완전 자동화 된 Provisioning 지원하는 Paas

##### Deployment 영역

- Early : Script 기반, 호스트 당 다중 서비스 배포

- Inception : VM 당 단일 서비스 배포

- Expanding : Container 당 단일 서비스 배포, Immutable Infra, Blue/Green Deployment

- Mature : Multi-Datacenter 배포

##### Monitoring 영역

- Early : APM

- Inception : Centralized Logging System

- Expanding : Container Monitoring

- Mature : Distributed Tracing, Trace as a Service, Synthetic Transaction

##### Governance 영역

- Early : 중앙집중화 된 Governance

- Inception : 일부 Monolith, 일부 Microservices의 Shared Governance Model

- Expanding : 완전 분산 Governance

- Mature : 참조 아키텍처 및 참조 방법론 등 지원
  
  - Expanding에서 완전 분산되고 다시 Mature에서 중앙집중되는 흐름

##### Team Sttructure 영역

- Early : Dev, QA, Ops 등 기술 별 조직

- Inception : 일부 Cross Functional 팀

- Expanding : 제품 기반 개발팀과 이를 지원하는 Platform 팀(운영, 모니터링 등)

- Mature : 완전한 제품 기반 DevOps 팀

##### Architecture 영역

- Early : ESB를 사용하는 SOA 기반 아키텍쳐 또는 Modular Monolithic

- Inception : Monolith 시스템에 신규 기능을 MSA로 개발

- Expanding : 모든 비즈니스 기능이 MSA로 분리되어 서로 Network 인터페이싱

- Mature : Event 기반, Serverless

## Section 04: MSA 분리 전략

### MSA 서비스 분리 원칙

#### 서비스 분리 전략

- 단계적 마이그레이션/ 처음에는 크게 추후에는 작게 분리/ 서비스 분리의 "공식"은 없다

#### 작고 분리가 쉬운 서비스로 워밍업

- MSA 성공적 전환을 위한 사전 준비사항
  
  - Cloud, Deployment Pipeline, Container, Monitoring

- 본격적 MSA 분리 전 간단한 서비스 분리하여 역량 내재화
  
  - 한 두개 테스트로 분리하여 인프라 등을 준비
  
  - 작은 Pilot 서비스로 내부 의존성이 가장 적은 기능을 선택한다.

#### 핵심 기능의 분리

- 분리할 핵심 기능의 도메인을 명확하게 해야함
  
  - 비즈니스 팀 구조를 기반으로 분리
  
  - 도메인 주도 설계 적용 : 고객 발생 이벤트를 시작점으로 부터 도메인 분리

- 핵심 기능은 다른 기능들과의 결합도가 높으므로
  
  - 이를 위한 상세한 의존성 분석 과정 필요
  
  - 정적 분석 프로세스(Method Call, Inheritance, Table Join etc)

#### 데이터의 분리

-  MSA 전환의 가장 큰 목적 중 하나인 서비스들의 독립적 배포를 위함

- 가장 피해야할 Anti-Pattern 중 하나가 서비스 별 공유 DB를 갖는 것
  
  - 공유 DB의 사용은 서비스간 결합도를 높이게 된다.

- 독립 저장소 및 데이터 Migration 전략 수립이 동반되어야 함

#### 분리 대상 선정

- MSA 전환 첫 단계로 조믹의 목표를 명확하게 수립
  
  - 가장 문제가 되는 기능이 무엇?
  
  - 비즈니스 요구사항 변경이 빈번할 기능?
  
  - 잦은 코드 수정으로 빌드/배포를 유발하는 기능?

- 서비스 내 변경의 관점에서 분리 대상 점검
  
  - 코드 커밋 히스토리를 파악하여 기능 별 빈도 분석
  
  - 프로젝트 로드맵 기반 향후 크게 수정될 기능 선정

#### 코드의 재사용 vs 재개발

- 분리 대상 서비스 확정 후 재사용/재개발 고민 필요

- 재사용의 경우 효율적으로 보이나 많은 문제 발생 가능
  
  - 오랜 기간 유지보수된 코드의 예로
  
  - 기술 부채 또는 오래된 기술 자체
  
  - 그 동안의 수없이 반영된 요구사항으로 현재 코드들이 현재 비즈니 도메인이 명확하게 반영되지 않을 가능성이 있다

- 재작성의 경우
  
  - 요구사항을 다시 파악하여 기능에 대한 비즈니스 도메인 명확화 가능

#### 진화적인 서비스 분리

- 서비스 분리 시 가장 큰 고민 중 하나가 분리될 서비스의 크기

- 원칙 : Go Macro, Then Micro
  
  - 우선 크게 분리하고 필요한 경우 재설계를 통해 더 작게 분리

- 서비스 크기가 너무 커도, 너무 작아도 문제이므로 반복적인 과정으로 진화적인 서비스 분리가 이뤄져야 함

- 서비스 크기에 대한 휴리스틱
  
  - Tow Pizza Team : 피자 2판으로 개발/운영이 가능한 서비스 크기
  
  - 한 사람의 머리로 전체 관리 가능한 수준
  
  - 2주 안에 완전 재작성 될 수 있는 수준

#### 반복/ 점진적 분리

- 전체 Monolith => MSA 전환은 길고 비용이 많이 드는 여정

- 크고 원대한 목표와 계획은 실패할 가능성이 높으므로, 작고 명확한 계획의 여러 단계 추진이 유리

- 한번에 하나씩 단계적으로 분리
  
  - The only thing a Big Bang re-architecture guarantees is a Big Bang! - Martin Fowler

- MSA 전환 중 클라이언트로부터의 Request를 신규 서비스로 전환

- Monolith에서 Method 호출하던 의존성을 모두 신규 서비스로 전환

#### MSA와 함께 신기술의 도입

- MSA는 혁신과 실험을 가능하게 한다만
  
  - 도입 초기의 실험/혁심은 복잡도를 증가한다

- step by step로 진행 필요

#### 서비스 분리와 조직

- 서비스를 분리하여 새로운 서비스를 만들 전담 팀 필요
  
  - 기존 기능을 유지보수하며 MSA 분리까지 하기 어려움

- 기존 모놀리식 기능도 계속 유지보수 되어야 함

- Cross Functional TFT 구성 : 기획, 디자인, 개발, 운영

- 첫 MSA 분리 성공까지 TFT인력은 다른 업무가 없어야 한다.

### 응집도와 결합도 그리고 SRP

- 



### 도메인 주도 설계



### Microservice 분리 프로세스

---

- 레퍼런스

> 
