- [Transaction](#transaction)
  - [트랜잭션](#트랜잭션)
    - [트랜잭션의 처리과정](#트랜잭션의-처리과정)
    - [트랜잭션의 조건(ACID)](#트랜잭션의-조건acid)
      - [원자성(Atomicity)](#원자성atomicity)
        - [원자성 보장](#원자성-보장)
        - [savePoint](#savepoint)
      - [일관성(Consistency)](#일관성consistency)
      - [격리성(Isolation)](#격리성isolation)
        - [격리성의 수준](#격리성의-수준)
          - [READ UNCOMMITED](#read-uncommited)
          - [READ COMMITED](#read-commited)
          - [REPEATABLE READ](#repeatable-read)
          - [SERIALBLE](#serialble)
      - [지속성(Durability)](#지속성durability)
# Transaction

## 트랜잭션

> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
> 
> 쪼갤 수 없는 업무 처리의 최소 단위
> 트랜잭션을 통해 데이터베이스의 완전성(intergrity) 유지를 확신

- 상태를 변화 = SQL 질의어를 통해 DB에 접근하는 것
  
  - `SELECT` , `INSERT` , `DELETE` , `UPDATE`와 같은 작업

- 작업 단위 = 사용자가 특정 기능의 수행을 위해 SQL작업을 묶는 단위

- 쪼갤 수 없는 업무 처리 = 여러개의 클라이언트가 액세스하거나, DB를 갱신 처리하는 과정에서 중단되는 경우 데이터 부정합을 방지하기 위한 최소 작업 단위

- 완전성(intergrinity) 유지 = 사용자 A 와 사용자 B가 10,000원을 송금하는 작압이 발생할때, 사용자 A의 계좌에는 10,000원 만큼 차감되고 B의 계좌에는 10,000원이 추가된다. A의 계좌에서 송금하는 과정에 오류가 발생했을 때, 작업은 취소(**rollback**)되지만 B의 계좌에는 그대로 10,000원이 추가(**commit**)될 수 있다. 이러한 상황에서 DB의 데이터 불일치가 나타날 수 있으므로 완정성 유지를 위해 트랜잭션이 필요하다.
  
  - rollback : SQL 처리를 처리 이전의 상태로 되돌린다.
  
  - commit : SQL 처리를 DB에 반영한다.

### 트랜잭션의 처리과정

1. Begin the transaction

2. Excute several quries - SQL질의들이 트랜잭션에 저장된다. DB 내 갱신이 아직 적용되지 않는다.

3. Commit the transaction - 트랜잭션이 성공적이며, DB 갱신이 실제 적용된다.
- 만약 2.의 과정중 SQL 쿼리 하나가 실패하면, 데이터베이스 시스템은 전체 트랜잭션 또는 실패한 쿼리를 rollback 한다.

### 트랜잭션의 조건(ACID)

- 트랜잭션이 실행되기 위해는 ACID라는 4가지의 특성을 만족해야 한다.

#### 원자성(Atomicity)

- 트랜잭션 내부에서 실행된 쿼리들은 **모두** 성공해서 commit되거나, 문제가 발생한다면 rollback을 통해 **모두** 취소되야 한다. 실행 쿼리 중 일부분만 성공할 수 없다.

##### 원자성 보장

- 트랜잭션 내에서 데이터베이스를 수정할 때, 해당 시점까지의 성공적인 상태가 롤백 이미지로 롤백 세그먼트라는 임시 영역에 저장된다.

- 오류가 발생하여 롤백이 발생한다면, 롤백 세그먼트 내의 상태로 원상 복구된다.

- 트랜잭션을 commit한 후에는 DB에 수정사항이 영구적으로 반영됨으로 롤백 세그먼트의 롤백 이미지는 삭제된다.

- 아주 많은 쿼리가 실행되는 트랜잭션 범위내에서 대부분의 로직이 성공적으로 수행됐는데, 마지막에 오류가 발생하여 롤백되는 경우가 있다고 하자. 오류가 발생하지 않은 영역까지 반복적으로 수행하는 건 비효율적이므로 성공적인 지점까지 **savePoint**를 설정할 수 있다.

##### savePoint

- 트랜잭션 내부에서 사용자가 지정할 수 있는 세부 작업 단위

- 트랜잭션 실행과정에서 특정 지점을 savePoint를 설정한 후 해당 지점으로 내부적으로 롤백 할 수 있다.

- 특정 savePoint 로 롤백한 뒤에는 이후의 savePoint들은 삭제된다.

#### 일관성(Consistency)

- 모든 트랜잭션은 일관성있는 데이터베이스 상태를 유지해야 한다.

- 트랜잭션 전 후의 데이터베이스의 상태는 **Correct State**여야 한다.
  
  - Correct State : 도메인의 유효범위, 무결성 제약조건 등의 제약조건을 위배하지 않는 정상적인 상태.
  
  - C라는 컬럼의 데이터 타입이 정수형이라면 트랜잭션 이후에도 정수형으로 유지되야 한다.

#### 격리성(Isolation)

- 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

- 트랜잭션은 기본적으로 원장성, 일관성 그리고 지속성을 보장한다. 하지만 격리성을 완전히 보장하기 위해서는 각각의 트랜잭션을 순차적으로 처리해야 한다.

- 이러한 특성은 동시성 처리 성능을 매우 나쁘게 한다. 따라서 격리성의 수준을 여러 단계로 나눈다.

##### 격리성의 수준

###### READ UNCOMMITED

- 상대방에 커밋하지 않은 데이터를 읽을 수 있다. 사용자 A가 트랜잭션 내에서 데이터 C를 수정하고 있을때, 사용자 B가 수정 중인 데이터 C를 조회할 수 있다, 커밋되지 않은 데이터를 조회하는 걸  Dirty Read라고 한다, 이때 사용자 B가 데이터 C를 사용하는 도중에 사용자 A가 데이터 C를 롤백하면 데이터 정합성이 깨질 수 있다.

###### READ COMMITED

- 상대방이 커밋한 데이터만 조회할 수 있다, 따라서 [Dirty Read](https://github.com/seho27060/TIL/tree/master/Springboot/220825%20springboot%20%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84)는 발생하지 않는다, 하지만 NON-REPEATABLE READ가 발생할 수 있다. 사용자 A가 커밋한 데이터 C를 사용자 B가 트랜잭션 내에서 조회하고 있을때, 이후에 사용자 A가 데이터 C를 수정 후 다시 커밋한다면 사용자 B는 같은 트랜잭션 내에서 다른 상태의 데이터 C를 조회하게 된다.

###### REPEATABLE READ

- 한번 조회한 데이터는 트랜잭션 내에서 다시 조회해도 같은 데이터가 나오는게 보장된다. 

- 하지만 PHANTOM READ가 발생할 수 있다. 예를 들어 사용자 A가 트랜잭션 내에서 게시글들을 조회할때, 트랜잭션 중간에 사용자 B가 새로운 게시글 D를 추가한다면, 다시 리스트를 조회했을때 나오는 결과가 달라질 수 있다.  

###### SERIALBLE

- 가장 엄격한 수준의 격리성이지만 동시성 처리에는 매우 약하다.



- 데이터베이스들은 보통 동시성 처리가 중요하기 때문에 **READ COMMITED**수준의 격리성을 사용한다.

#### 지속성(Durability)

- 성공적으로 수행된 트랜잭션은 영원히 기록된다. 중간에 시스템 문제가 발생했을때, 데이터베이스 로그를 참고해서 성공했던 트랜잭션을 복구 할 수 있다.

---

- 레퍼런스


> [트랜잭션 - 해시넷](http://wiki.hash.kr/index.php/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)[트랜잭션 - 해시넷](http://wiki.hash.kr/index.php/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
> 
> [[Database] 트랜잭션이란? — 깊게 자라기](https://devjem.tistory.com/27#%EC%-B%--%EC%-E%--%EC%--%B--Automicity-)
> 
> [DB 트랜잭션(Transaction) | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/data-base/Transaction.html)
