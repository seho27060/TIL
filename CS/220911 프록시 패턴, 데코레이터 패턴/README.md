# 프록시 패턴/ 데코레이터 패턴

#### 프록시(Proxy)

- 대리자라는 뜻으로, 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서, 클라이언트의 요청을 받아주는 역할을 한다. 

- 클라이언트가 원래 요청하려는 대상, 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 `타깃`이라고 한다.
  
  - 클라이언트 -> 프록시 -> 타깃 의 구조라 생각하자.

- 엔티티 A에 엔티티 B가 `ManytoOne`과 같은 연관관계로 맺어져 있을때,
  
  엔티티 A 객체를 호출하면 연관관계에 의해 엔티티 B도 호출된다.

- 프록시는 사용목적에 따라 **데코레이터 패턴**과 **프록시 패턴**으로 구분된다.

- 위와 같은 상황에서 엔티티 B의 사용여부에 상관없이 호출되는 비효율적 상황을 예방하기 위해 프록시 객체를 사용한다.

## 디자인 패턴

### 프록시 패턴

- 호스트 클래스를 수정하지 않고 프록시에서 새로운 기능을 추가한다.
- 

#### 대표적 형태

##### 가상프록시

- 필요로 하는 시점까지(사용되는 시점) 객체의 생성을 연기하고, 해당 객체가 생성된 것 처럼 동작하도록 만들고 싶을때 사용.

- 한개의 객체에 정의된 메서드, 연관 엔티티 등을 사용하기 전에는 프록시형태로 가지고 있고, 사용요청이 확인되면 그때 실제 객체에 요청한다. 
  
  - 이를 통해 미리 객체 관련 메서드, 엔티티를 구현하여 리소스를 낭비하는 걸 방지 할 수 있다.

##### 원격프록시

- 원격 객체에 대한 접근을 제어 로컬 환경에 존재한다. 

- 원격 객체에 대한 대변자 역할을 하는 객체는 로컬, 실제 객체는 다른 주소에 있는 공간에 있다.

- 두개의 대변자 - 실제 객체들이 같은 주소 공간에 있는 것처럼 동작하게 한다.

##### 보호프록시

- 호스트 클래스에 대한 접근을 제어하기 위한 경우

- 객체에 대한 접근 권한을 제어하거나 객체마다 접근 권한을 달리할때 사용한다.

#### 프록시 패턴의 장단점

##### 장점

- 사이즈가 큰 객체가 로딩되기 전에 프록시를 통해 참조할 수 있다(리소스 낭비 방지)

- 실제 객체의 public, protected 메서드들을 숨기고 인터페이스를 통해 노출할 수 있다.

- 객체의 접근에 대한 사전처리 가능

##### 단점

- 객체를 생성할 때, 프록시라는 단계를 추가로 거치게 되므로 빈번한 객체 생성이 발생하면 성능저하가 우려된다.

- 프록시 내부에 객체 생성을 위한 스레드 생성, 동기화가 구현될 경우에도 성능저하 우려

- 로직이 난해해져 가독성이 떨어질 수 있다.

### 데코레이터 패턴

- `타깃`에 부가적인 기능을 런타임시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴

- 전체 클래스에 새로운 기능을 추가할 필요는 없지만 개별적인 객체, 즉 `타깃`에 새로운 기능(책임)을 추가할 필요가 있다.
  
  - 가령 모든 사용자 인터페이스에 특정기능 C가 있어야하는건 아니지만, 어떤 특정 사용자에게는 C 기능이 있어야 할때
  
  - 새로운 기능을 객체의 속성에 추가됨으로 하나의 또 다른 책임 추가된다.

- 보통 위와 같은 상황에서는 클래스 객체를 상속받아, 기능을 추가한다. 하지만 별로 유용하지 않다. 상속을 통한 객체 정의는 정적이고 사용자는 구성요소를 언제 어떻게 장식해야하는지 제어할 수 없다.

- 객체의 기능 추가를 동적이고, 사용자가 구성요소를 제어하기 위해 **데코레이터**를 사용한다.

#### 데코레이터

- 장식자(decorator)라고 한다.

- 장식자 자신이 둘러싼 요소, 구성 요소가 갖는 인터페이스를 장식자 자신도 동일하게 제공하므로, 장식자의 존재는 사용자에게 감춰진다.

- 장식자는 자신이 둘러싼 구성 요소로 전달되는 요청을 중간에 가로채서 해당 구성 요소에 전달한다.
  
  - 전달과정 앞뒤에 다른 작업 구현 가능
  
  - 투명성이 존재하므로 장식자의 중첩이 가능하다.

#### 언제 사용할까?

- 객체의 타입과 호출 가능한 메소드를 그대로 유지(사용자가 객체를 사용하는데 변화가 없음)하면서 객체에 새로운 책임을 추가할 때

- 탈부착 가능한 책짐을 정의할 때

- 상속을 통해 서브클래스를 계속 만드는 방법이 비효율적일 때 사용한다.

#### 구현시 고려 사항

- 가급적 인터페이스만을 정의한다.
  
  - 무언가 저장하는 변수는 정의하지 않는다. 저장할 것이 있다면 서브클래스에서 하자.

- 상속 구조를 통해 `Decorator`와 `Component`가 같은 인터페이스를 갖게 해야 한다.
  
  - 투과적 인터페이스 : `Decorator`로 `Component`를 감싸도 메서드는 계속 사용할 수 있다.

#### 주의사항

- public 메서드가 많다면 `Decorator` 적용이 바람직하지 않을 수 있다.
  
  - 데코레이터는 **Design Patterns**에서 말하는 '투명한 외투' 로서 존재해야 하기 때문이다. 호스트 클래스가 제공하는 모든 public 메서드를 데코레이터도 구현해야 하는데, 이는 비효율적일 가능성이 크다.

- 데코레이터가 여러 개 있다면 순서에 주의하도록 한다.
  
  - 순차적으로 적용되어 원하는 결과를 얻지 못할 수 있다. 데코레이터가 여러개 존재해도 독립적이고 배열 순서에 상관없이 동작하는게 좋으나..실제론 힘드므로
  
  - 클라이언트가 데코레이터 객체를 직접 만들 수 없도록 하고, **대신에 데코레이터 간의 안전한 조합을 제공하는 특별한 생성 메서드를 클라이언트에 제공하는게 좋다.**

- 코드가 여러 클래스로 흩어져 디버깅이 까다로워지고, 이해하기 어려워질 수 있다.

##### 출처

> [데코레이터 패턴 (Decorator Pattern) - 기계인간 John Grib](https://johngrib.github.io/wiki/pattern/decorator/)
> 
> [[Design Pattern] 프록시 패턴(Proxy Pattern)에 대하여](https://coding-factory.tistory.com/711)
