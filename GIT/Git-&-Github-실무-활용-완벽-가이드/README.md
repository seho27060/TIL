[TOC]

# Git & Github 실무 활용 완벽 가이드

## Section 14: Git 협업 워크플로우

### 126. 이 섹션에서 중요한것

- 중앙집중형 워크플로우

- 풀 리퀘스트

- 포킹

- Fork And clone workflow

#### 중앙집중형 워크플로우

- 가장 단순한 최악의 워크플로우

- 모든 사람이 메인 또는 마스터 브랜치에서 작업한다.

- 협업을 위해서 메인 브랜치에 푸쉬를 하게되면,, 모든 사용자가 불완전한 코드를 공유받게된다.

- 단일 브랜치 운용으로 인한 위험과 불편함

### 129. 중요한 Feature branch 워크플로우

- 흔히 사용하는 워크플로우.
  - 기능 개발한 브랜치를 따로 파고 메인 브랜치에 push 또는 PR

## Section 15: 리베이스는 가장 까다로운 Git 명령어일까?

### 140. 이 섹션에서 가장 중요한 것

- `rebase`와 `merge`의 차이점

### 141. 리베이스가 어려운 이유, 정말 그럴까?

- 유용한 기능이지만, 사용하지 않을때를 알아야 한다.

- `merge` 대신 사용하기도 한다

### 142. `merge`와 `rebase` 비교하기

- 두 명령어 모두 브랜치를 병합하는 기능을 한다.

- 마스터브랜치에 푸시가 잦은 프로젝트에서 내가 가진 피처 브랜치가 마스터 브랜치와 형상이 항상 같을 수 없다.
  
  - 이럴때는 마스터 브랜치에 커밋이 발생할때마다 나의 피처 브랜치로 머지해줘야 동일한 형상이 유지된다.
  
  - 그렇다면 리베이스는?

#### rebase

- 리베이스란 피처 브랜치의 베이스를 새로 설정하는 작업

- 머지로 인한 작업으로 마스터 브랜치와 피처 브랜치가 병렬적으로 놓이는게 아닌, 리베이스로 인해 마스터-피처 브랜치 간 일직선으로 놓여지는 관계로 형성된다.

- ```git
  git switch feature
  git rebase master
  ```

### 141. 리베이스 데모

- 마찬가지로, 마스터 브랜치에서 생성한 피처 브랜치에서 작업하는 중에 마스터 브랜치에 푸시가 계속되면 그럴때마다 피처 브랜치에 머지를 하고 머지 커밋이 생성된다.

- 마스터 브랜치가 업데이트될때마다 피처 브랜치에 마스터 브랜치를 머지하는게(머지 커밋이 생성되는게) 아닌, 마스터 브랜치의 변경마다 피처 브랜치에 병합할 순 없을까?

- 리베이스는 머지=> 머지 커밋의 작업이 아닌, 피처 브랜치의 기존 히스토리에 마스터 브랜치의 히스토리를 업데이트하여 "덧붙인다"
  
  - 마스터 브랜치에는 아무런 영향이 없고, 피처 브랜치에 마스터 브랜치의 변경사항이 병합되고 히스토리들은 마스터 브랜치의 내용과 병합되어 유지된다.
  
  - 결과적으로 마스터-피처 간 병렬적인 그래프가 아닌 직선 그래프가 생성된다.

- ```git
  git switch feature
  git rebase master
  ```

- 피처 브랜치에 마스터 브랜치를 리베이스한 후, 깃 로그를 찍어보면 머지할때 로그에 머지 커밋이 남는 것과 달리 머지 커밋없이 마스터 브랜치와 피처 브랜치의 히스토리가 병합되어 유지된다.(마스터와 피처 브랜치의 히스토리 형상이 기본적으로 동일하다. 피처 브랜치의 커밋은 당연히 아직 마스터에 반영되지 않은 상태)

- 한마디로 마스터 브랜치에 피처 브랜치를 올리는 것이다.(마스터 브랜치 히스토리 마지막에 피처 브랜치의 히스토리가 덧붙여짐)

### 145. 기본 원칙: 리베이스를 하면 안되는 경우

- 다른 개발자들이 이미 가져간 커밋을 리베이스하면 안된다.
- 나의 피처 브랜치 커밋을 마스터에 반영한 후, 다른 개발자들이 pull한 상태에서 나의 피처 브랜치를 마스터 브랜치에 리베이스하면 커밋들이 재작성(rewrite)된다.
  - 재작성된 커밋들은 완전히 새로 생성되는 것으로, 이전의 커밋 id와 다른 값으로 결과적으로 내가 이전에 반영한 커밋들을 가져간 개발자들의 히스토리와 내가 방금 리베이스한 피처 브랜치의 히스토리의 형상이 불일치하는 결과를 불러온다.
  - 이러한 형상(히스토리)불일치를 해결하는 것은 매우 번거롭다.
- **이미 공유한 커밋은 리베이스하지 말자.**

### 146. 충돌과 리베이스 다루기

- 리베이스에서도 충돌이 발생할 수 있다.
  
  - 피처에서 커밋한 후, 마스터에서 동일한 파일에 커밋이 발생하여 피처 브랜치에서 마스터 브랜치를 리베이스한다면 충돌이 발생한다.
  
  - 리베이스로 커밋 히스토리가 재작성되는 과정에서 충돌이 발생한 부분에서 중단된다(생성된 히스토리들은 남는다.)
    
    - 이 경우 리베이스를 중단하거나, 충돌 파일에서 해결이 필요하다.

## Section 16: Interactive Rebase를 사용하여 히스토리 삭제하기

### 147. 이 섹션에서 가장 중요한 것

- 인터액티브 리베이스로 히스토리 정리하기.

### 148. Interactive Rebase 소개

- 리베이스의 기능은
  
  - 머지 기능 대체
  
  - 정리 도구로서의 활용

- 이때 정리 도구라는 것은, 나의 브랜치에서만 이뤄져야한다.

- 사용 명령어
  
  ```git
  git rebase -i HEAD~${과거로 이동하고 싶은 커밋 수만큼의 숫자}
  ```
  
  다른 브랜치를 현재 브랜치에 리베이스하는게 아닌, 현재 브랜치를 새롭게 리베이스하는 것임에 유의한다.

- 이미 반영된 커밋을 인터액티브 리베이스로 커밋 메시지들을 수정할 수 있다.
  
  - 메시지 변경, 삭제, 병합등이 가능하다.

- 인터액티브 리베이스 실행시, 전용 에디터가 실행되며 pick, reword, fixup, drop등과 같은 명령어로 원하는 작업을 수행할 수 있다.

- 변경한 커밋부터 최신 커밋까지는 "재작성"되어 새로운 커밋으로 대체되므로 커밋 id 또한 새롭게 생성되어 변경된다.

## Section 17: Git tag-히스토리상 중요한 순간에 표시하기

### 152. What Really Matters in This Section

- 보통 릴리즈나, 프로젝트 버전 표시를 위해 사용한다.

### 153. Git Tag 이면에 담긴 생각

- 깃 태그는 특정 커밋에 추가하는 일종의 라벨
  
  - 시간(커밋)의 어느 지점을 가리키는 것 과 같다.

- 태그의 두 가지 종류
  
  - lightweight tag: 특정 커밋에 네이밍이나 라벨링에 사용하는 일반 태그
  
  - annotated tag:  추가 메타 데이터(저자 이름, 이메일, 날짜, 태깅 메시지 등)을 포함하는 주석 태그

### 154. 시맨틱 버전 관리에 대한 참고 사항

- 태그의 주된 사용처는 소프트웨어 버전 및 릴리스 표시

- 태그에는 시맨틱 버저닝이 적용된다.
  
  - 시맨틱 버저닝: 버전 번호를 매기는 일종의 규약, 명세, 규칙
  
  - 보통 메이저 릴리스.마이너 릴리스. 패치 릴리스 같이 2.4.1 로 표현된다.
  
  - 패치는 버그픽스, 단순 변경/ 마이너는 특정 기능의 추가/ 메이저는 하위 버전의 호환성을 보장하지 못하는 중대한 변경 사항을 의미한다.

### 155. 태그 보기 및 검색하기

#### Viewing Tags

- `git tag` 가 기본 명령어로 태그 리스트를 확인한다.

- `git tag -l "*blah*"` 와 같이 정규표현식으로 원하는 태그만 출력할 수 도 있다.

### 156. Git Diff로 태그 비교하기

- `git checkout <태그>`로 원하는 태그로 형상을 이동할 수 있다.
  
  - 브랜치를 변경하는 것과 비슷하지만, 브랜치의 경우 커밋이 추가되어 형상이 동적이지만
  
  - 태그의 경우 정적으로 정해진 커밋 위치로 이동한다는 차이점이 있다.

- `git dff <태그1> <태그2>` 로 서로 다른 2개 태그의 코드 변경 사항을 확인할 수 있다.

### 157. 일반 태그 & 주석 태그 생성하기

- `git tag <tagname>` 으로 현재 헤드가 가리키는 곳에 일반 태그(lightweight tag)를 생성한다.

- `git tag -a <tagname>` 으로, 현재 헤드가 가리키는 곳에 주석 태그(annotated tag)를 생성한다.
  
  - 태그 메시지 에디터가 띄워져 추가 메타 메시지(extra meta message)를 작성할 수 있다.
  
  - `git show <tagname>` 으로 원하는 주석 태그의 내용을 확인 할 수 있다.

- ` git tag <tagname> <commitId>` 로 원하는 이전의 커밋에 태그를 추가할 수 있다.

- `git tag -d <tagname>`으로 원하는 태그를 삭제할 수 도 있다.

### 162. 중요: 태그 푸시하기

- 로컬에서 태그를 추가하고 브랜치를 푸시한다고 해서 태그도 추가되지 않는다.

- `git push --tag`로 로컬의 모든 태그를 리모트에 푸시하거나, `git push origin <tagname>` 으로 원격 저장소에 원하는 태그 1개를 푸시하는 2가지 방법이 있다.

## Section 18: Git의 이면 - 해싱(Hashing)과 객체

### 163. 이 섹션에서 중요한 것

- 로컬 설정 파일

### 164. 로컬 파일로 작업하기

#### What is .git?

- 깃 원격 저장소를 로컬에 클론시 생성되는 깃 설정 관련 디렉토리

- `config` 파일에 설정값을 통해 원하는 옵션을 줄 수 있다.
  
  - 현재 저장소에만 영향받음
  
  - ` git config`  명령어로도 변경 가능하다.

- `refs` (references) 폴더는 저장소 관련 정보가 저장된다.
  
  - `heads`, `remote`, `tags` 등에 각각의 브랜치, 원격 브랜치, 태그 정보가 담겨있다.

- `head` 파일은 현재 내가 바라보고 있는 커밋을 나타낸다.
  
  - 브랜치를 바라볼 경우 `/refs/heads/master`와 같이 바라보는데, 브랜치의 경우 업데이트에 따라 커밋이 동적이다
  
  - 특정 커밋으로 형상을 변경할 경우 헤드는 해당 커밋의 해쉬를 갖게 된다.

### 170. Git Hash-Object로 해싱하기

- 깃은 일종의 키 밸류 데이터베이스로 관리된다.
  
  - 해쉬를 키로 하여 파일, 형상 등을 밸류로 저장한다.

- 깃에서 여러 해쉬 객체(tags, commit 등)에 해쉬를 사용하는데, 이때 생성된 해쉬 값은 `.git/objects`에 해쉬값의 앞 2자리를 디렉토리로 하여 저장된다.
  
  - `echo "hello" | git hash-object --stdin -w` 를 통해 표준으로 출력된 hello 값이 깃 해쉬오브젝트로 저장된다. 

- 이때 `.git/objects`에 저장된 해쉬 값을 통해 `git cat-file -p <objects-hash>` 명령어를 사용하여 저장된 객체를 확인할 수 있다.
  
  - 위 표준출력과 같이 파일또한 저장이 가능하다.
  
  - `text.txt`라는 파일에 1을 입력하여 저장한 후 `git hash-object -w text.txt`로 해당 파일의 해쉬값이 저장된다.
  
  - 다음 `text.txt`에 2라는 값을 추가하여 다시 `git hash-object`로 저장한다면, 다른 해쉬 값을 저장한다.
  
  - 이렇게 파일의 형상에 따라 다른 해쉬값을 저장한다.
  
  - `git cat-file -p <object-hash> > text.txt`로 `text.txt`가 1만 입력된 상태일때의 해쉬값을 `object-hash`에 할당하여 명령어를 사용하면, 마지막에 파일에 저장된 1,2가 아닌 처음에 저장한 1로 파일이 변경된다.(git에서 커밋id를 통해 형상을 변경하는 원리)

- 레포의 `.git/objects`에 저장된 모든 파일을 blobs(블롭, binary large object)라고 부른다.
  
  - 블롭은 파일의 내용이 저장한다. 파일의 제목은 저장되지 않는다.

- 트리는 일종의 깃 객체로, 파일간 관계를 나타내는 디렉토리 관계(내용)를 저장한다.
  
  - 블롭은 파일의 내용, 트리는 디렉토리의 내용
  
  - 디렉토리의 내용에는 블롭, 트리가 저장된다.
  
  - 트리 아래에 저장된 트리를 다시 참고하는.. 알고리즘 객체의 트리의 형식을 띈다.

- 커밋 역시 해쉬 객체로 트리와 부모 커밋의 해쉬 값을 갖는다.
  
  - 커밋이 갖는 트리는 어떤 하나의 형상이 저장된 형태(스냅샷)이다.
  
  - 커밋이 갖는 부모 커밋 해쉬값으로, 부모 커밋은 바로 직전의 커밋을 의미한다.

- 깃 해쉬 객체 구조로 깃 작동 방식이 어떻게 되는지 조금이나마 이해가 되는 느낌.

## Section 19: Reflog의 힘 - '사라진' 작업 복구하기

### 175. 이 섹션에서 가장 중요한 것

- `reflog`에 대해 알아보자

- `reflog`를 통해 `rebase`를 되돌릴수도 있다.

- `reflog` 자체가 자주 사용되는 명령어는 아니나, 알고 있다면 도움된다.

### 176. `reflog` 소개

- 깃이라는 것은 레퍼런스(참조값)을 저장하는 하나의 데이터베이스이다.

- `.git/` 경로의 `HEAD` 파일에는 현재 헤드의 기록이 남게 된다. `git reflog show HEAD`를 통해 헤드의 이동 경로를 확인할 수 도 있다.
  
  - 깃 로그에서는 브랜치 체크아웃에 대한 기록은 없지만, `reflog`에는 남는다.
  
  - 깃 로그에는 남지 않는 기록이 `reflog`에는 남을 수 있다는 의미

- reflog에 기록된 내용을 통해 다른 명령어에 활용할 수 있다.
  
  - `name@{qualifier}` 와 같은 형태로 `reflog`를 참고 하여 이동할 수 있다.
    
    - `qualifier`에는 yesterday, 2.day.ago, one.week.ago 와 같은 값이 할당될 수 있다.
  
  - `git checkout HEAD@{2}`: reflog 상에서 HEAD가 2개 단계 전으로 이동한다.
  
  - `git checkout HEAD~2`와는 다른데, 해당 명령어는 HEAD의 부모 커밋을 참고하여 2개 전으로 이동한다 이다.
  
  - `git checkout master@{1.week.ago}`를 사용한다면, 마스터 브랜치가 1주일 전 바라보는 커밋으로 형상을 이동을 할 수 있다.

### 181. reflog로 사라진 커밋 복구하기

- `git reset --hard`로 커밋을 잃어버린 뒤 `reflog`를 통해 데이터를 복구할 수 도 있다.

- `git reset --hard`로 형상을 변경한 후 `git log`로 확인하면, 커밋이 사라진 걸 볼 수 있지만, `reflog`에서는 모든 행동과 형상을 기억하므로 `name{qualifier}`를 활용하여 `git log`에서 확인 할 수 없는 내용을 복구할 수 있다.

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

## Section 01: title

### index1

#### detail-index1

---

- 레퍼런스

> 
