# Springboot_02

## JPA(Java Persistence API)

- Java ORM 표준(사용법, interface)

- Java의 클래스와 DB의 테이블과 매핑하는 것 

- 하나의 인터페이스
  
  - 라이브러리 스프링 DATA JPA에서  함수의 이름을 통해서 알아서 세부내용 구현
  
  - 함수 이름에 따른 정해진 매개변수, 반환타입을 따르면 된다.

### jpa

- 서버 - (java) -> JPA -> (sql) -> DB 와 같이 서버(java)와 디비(sql)간의 자동 변환을 기능함

- 엔티티의 요소를 수정할때는 컨트롤러의 정의에 `@setter`를 붙이는게 아니라, 명시적인 메서드를 선언하여 사용한다.

### 영속성 컨텍스트

- 엔티티를 영구저장하는 환경/ 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 역할

- 디비에서 가져온 값을 엔티티 클래스에 대입

#### 영속성 컨텍스트의 특징

1. 1차 캐시 - 영속성 컨텍스트 내부에 1차 캐시가 존재한다. 이곳에 영속 상태의 엔티티를 저장한다.
   
   - 조회 흐름
     
     1. 1차 캐시에서 엔티티를 찾는다.
     
     2. 1차 캐시에 있으면 캐시에서 조회/ 없으면 디비에서 조회한다.
     
     3. 조회 데이터로 엔티티를 생성해 1차 캐시에 저장한다.(엔티티를 영속상태로)
     
     4. 조회 엔티티 반환

2. 동일성 보장 : 저장된 엔티티의 실제 인스턴스가 같은 동일성을 보장한다.

3. 트랙잭션을 지원하는 쓰기 지원

4. 변경감지
   
   - 엔티티에서 변경 발생시, 변경을 감지하고 디비에 매핑되는 테이블에 업데이트 쿼리를 저장함(디비에 날리는거 아님)
   
   - 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 디비에 반영하는 데, 이를 **flush**라고 한다.
   
   - 변경감지 흐름
     
     1. 트랜잭션 커밋시, 엔티티매니저내부에 플러시 호출
     
     2. 엔티티와 스냅샷을 비교하여 변경된 엔티티를 찾는다.
     
     3. 변경 엔티티 발견시, 수정 쿼리를 생성하여 쓰기지연 SQL저장소에 저장
     
     4. 수정과정에 문제가 없다면 쓰기 지연 저장소의 SQL을 플러시한다.
     
     5. 데이터베이스 트랜잭션을 커밋한다.

5. 지연 로딩
- 메서드에 `@Transaction`이 붙으면 저장된 쿼리를 디비에 날린다.

- `@Transactional`

- `Service`의 구현에서 디비에 수정/삭제에 대해 신뢰성을 보장해주는 어노테이션
  
  - 디비와 소통한다.
  
  - 디비와 소통하기 전부터, 하고난 후까지 체크
  
  - 디비와 소통중 에러가 나면, 디비와 소통전으로 되돌리고
  
  - 정상적으로 소통이 끝나고 쿼리가 디비에 날아갔다면, 결과를 디비에 확정짓는다.
  
  - 메서드 하나에 붙여줄수도 있지만, 서비스 구현 전체에 달아줄수도 있다.

- Flush(플러시)
  
  - 영속성 컨텍스트의 변경 내용을 DB에 반영한다. 엔티티를 지우는게 아닌, 변경 내요을 DB에 동기화한다.

## 연관관계

### JPA에서의 연관관계

- 스프링에서나 연관관계를 나타낼때 연관 데이터의 객체를 갖고, db상에서는 외래키하나만 갖게된다.

- `@OneToMany(mappedBy = "name")` : 일대다 관계

- `@ManyToOne()` : 다대일 관계

#### 연관관계의 주인

- 일대다 관계에서 "다"인 엔티티가 외래키를 갖는다.

- 외래키를 갖는 쪽을 연관관계의 **주인**이라고 한다.

#### 지연로딩 전략

- 즉시로딩 전략을 택할 경우 엔티티를 조회할때 해당 엔티티와 연관 관계에 있는 엔티티도 함께 조회된다.
  
  - 영속성 컨텍스트에서는 조회를 감지하고 연관관계의 엔티티를 조회한다.
  
  - 일대다, 다대일 관계이므로 조회의 과정은 **순환적으로** 이뤄지게 된다.( 아래의 순환참조 문제발생)

- 위와 같은 즉시로딩 전략을 택할 경우 발생 가능한 문제를 방지하기 위해 지연로딩 전략을 택한다.

- 지연로딩 : 엔티티를 조회할때 연관된 엔티티를 실제 **사용할때만** 조회한다.

- `@ManyToOne(fetch=FetchType.LAZY)`

- `fetch=FetchType.LAZY`로 지연로딩 전략을 택하였다.

#### 순환참조

- 즉시로딩 전략을 택할 경우, 연관관계의 엔티티는 동시에 쿼리가 날아간다. 이로인해 순환 참조의 문제가 발생한다.

- 지연 로딩을 통해 해결이 가능하나, 단순히 지연로딩만 사용하는게 아닌 반환용  DTO를 생성하여 사용함으로, 연관 관계의 엔티티를 순환 참조하는 상황을 방지하자.

- 되도록 응답/반환용 DTO를 만들어 사용하자.
  
  - DTO를 새로 생성하고, 빌더 패턴을 할당해서 한다.
