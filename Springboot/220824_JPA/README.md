- [Springboot_02](#springboot_02)
  
  - [JPA(Java Persistence API)](#jpajava-persistence-api)
    
    - [jpa](#jpa)
  
  - [연관관계](#연관관계)
    
    - [JPA에서의 연관관계](#jpa에서의-연관관계)
      
      - [연관관계의 주인](#연관관계의-주인)
      
      - [지연로딩 전략](#지연로딩-전략)
      
      - [순환참조](#순환참조)

# Springboot_02

## JPA(Java Persistence API)

- Java ORM 표준(사용법, interface)

- Java의 클래스와 DB의 테이블과 매핑하는 것 

- 하나의 인터페이스
  
  - 라이브러리 스프링 DATA JPA에서  함수의 이름을 통해서 알아서 세부내용 구현
  
  - 함수 이름에 따른 정해진 매개변수, 반환타입을 따르면 된다.

### jpa

- 서버 - (java) -> JPA -> (sql) -> DB 와 같이 서버(java)와 디비(sql)간의 자동 변환을 기능함

- 엔티티의 요소를 수정할때는 컨트롤러의 정의에 `@setter`를 붙이는게 아니라, 명시적인 메서드를 선언하여 사용한다.

## 연관관계

### JPA에서의 연관관계

- 스프링에서나 연관관계를 나타낼때 연관 데이터의 객체를 갖고, db상에서는 외래키하나만 갖게된다.

- `@OneToMany(mappedBy = "name")` : 일대다 관계

- `@ManyToOne()` : 다대일 관계

#### 연관관계의 주인

- 일대다 관계에서 "다"인 엔티티가 외래키를 갖는다.

- 외래키를 갖는 쪽을 연관관계의 **주인**이라고 한다.

#### 지연로딩 전략

- 즉시로딩 전략을 택할 경우 엔티티를 조회할때 해당 엔티티와 연관 관계에 있는 엔티티도 함께 조회된다.
  
  - 영속성 컨텍스트에서는 조회를 감지하고 연관관계의 엔티티를 조회한다.
  
  - 일대다, 다대일 관계이므로 조회의 과정은 **순환적으로** 이뤄지게 된다.( 아래의 순환참조 문제발생)

- 위와 같은 즉시로딩 전략을 택할 경우 발생 가능한 문제를 방지하기 위해 지연로딩 전략을 택한다.

- 지연로딩 : 엔티티를 조회할때 연관된 엔티티를 실제 **사용할때만** 조회한다.

- `@ManyToOne(fetch=FetchType.LAZY)`

- `fetch=FetchType.LAZY`로 지연로딩 전략을 택하였다.

#### 순환참조

- 즉시로딩 전략을 택할 경우, 연관관계의 엔티티는 동시에 쿼리가 날아간다. 이로인해 순환 참조의 문제가 발생한다.

- 지연 로딩을 통해 해결이 가능하나, 단순히 지연로딩만 사용하는게 아닌 반환용  DTO를 생성하여 사용함으로, 연관 관계의 엔티티를 순환 참조하는 상황을 방지하자.

- 되도록 응답/반환용 DTO를 만들어 사용하자.
  
  - DTO를 새로 생성하고, 빌더 패턴을 할당해서 한다.
