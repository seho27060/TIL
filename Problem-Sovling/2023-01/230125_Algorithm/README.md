# 230125-BOJ-LCS 2

## LCS 2

- https://www.acmicpc.net/problem/9252

- LCS(Longest Common Subsequence) 문제, 근데 가장 긴 길이의 부분 수열과 해당 부분 수열을 출력해야함

#### 풀이과정

1. 문제 읽고 도저히 감을 못잡아서 힌트봄!

2. `DP`와 `역추적`을 활용하는 문제..

3. `aStr`,`bStr` 두 개 수열 길이 `n*m` 크기의 행렬 `result`에 누적합 형식을 구한다.

4. |     | b   | c   | d   | e   |
   | --- | --- | --- | --- | --- |
   | a   | 0   | 0   | 0   | 0   |
   | d   | 0   | 0   | 1   | 1   |
   | e   | 0   | 0   | 0   | 2   |

5. `0 <= j < m`번째 `bStr` 수열의 인자와 `0 <= i < n`번째 `aStr`수열의 인자와 같다면 `result[i][j] = result[i-1][j-1] + 1`을 수행하고

6. 아니라면 `result[i][j] = max(result[i-1][j],result[i][j-1])`을 수행하면 `DP`형식으로 구할 수 있다.

7. 이건 "길이"만 구한거고, 이제 `aStr`와 `bStr`의 길이대로 `역추적`하여 현재 위치(`i,j`)와 왼쪽 대각선(`i-1,j-1`)의 값이 같다면 현재 위치의 인자를 `answer`에 추가하고

8. 아니라면 위쪽(`i-1,j`), 왼쪽(`i,j-1`)중 더 큰 값으로 이동만 한다.

9. 위 과정으로 생성된 `answer`을 역순으로 하여 출력한다..

#### 성과 및 피드백

- 하...동적 계획법.. 진짜 방식을 알 수 가 없다.
- `LIS`에 이어서 `LCS`알고리즘을 알게 되었다.  `DP`를 활용한 풀이법을 더 공부하자.

##### LCS

- `n*m`의 행렬이나, `n`짜리 행렬로도 구할 수 있다.

- `(i,j)`행렬을 순회하면서 `(i,j-1)`과 `(i-1,j)`인자와 현재 `j` 번째 수열의 값이 일치하면 `+1`하는 방식으로 구할 수 있다..

---

#### 레퍼런스

> [[백준9252번] LCS 2 / Python3](https://hooongs.tistory.com/184)
