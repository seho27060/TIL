[TOC]

# Docker & Kubernetes 03

## 데이터 관리 및 볼륨으로 작업하기

### 데이터 카테고리

- 애플리케이션 = 소스코드 + 환경
  
  - readonly로 이미지에 저장

- 임시 애플리케이션
  
  - read-write인 컨테이너 레이어에 저장된다.
  
  - 원래 애플리케이션에 동적으로 수정된 데이터로 원래 이미지에 수정 내용이 추가된다. -> 메모리에 저장됨

- 영구 애플리케이션(Permanent App Data)
  
  - 데이터베이스에 저장되며 컨테이너의 중지, 재시작에도 남게 된다.
  
  - read-write 데이터로 영구적으로 **컨테이너**와 **볼륨**에 저장된다

#### 문제이해

- 도커의 컨테이너는 "독립적"이다.
  
  - 로컬에서 이미지 생성 - 컨테이너 실행 - 컨테이너 내부에서 파일 생성 후 저장
  
  - 위 단계를 거쳐도 생성된 새로운 파일은 로컬에서 간섭하지 못한다.
  
  - 도커의 컨테이너는 그 자체의 **독립적인(격리된,isolated) 파일 시스템**을 가지기 때문이다.
  
  - 이건 문제안됨

- 도커의 컨테이너는 "임시적"이다.
  
  - 위에서 독립적인 컨테이너를 생성하고, 그 안에서 새로운 파일 `newfile`을 생성하여 저장했다.
  
  - 이때 해당 컨테이너를 중지 후, 재시작해도 새로운 파일 `newfile`은 여전히 존재한다.
  
  - 하지만 해당 컨테이너가 삭제될 경우? -> 관련된 모든 데이터는 삭제된다.
  
  - 컨테이너가 삭제되어도 남아있어야 하는 데이터(ex : 제품 정보, 고객 정보, etc..)는 어떻게 관리해야 할까? -> Volume!

### 볼륨 소개

#### 볼륨

- **호스트 머신**에 저장된 데이터

- 마운팅되어 도커의 컨테이너 내부의 폴더에 **매핑**된다.
  
  - 컨테이너 외부의 데이터와 연결을 통해 컨테이너의 제거에 독립적인 데이터를 read/write할 수 있게 된다.

#### 볼륨 추가하기

- 익명 볼륨
  - `Dockerfile`에 `VOLUME ["저장위치"]`를 추가한다.
  - 해당 방법으로 생성된 볼륨은 "익명 볼륨"으로 실행한 컨테이너와 1대1연결이다.
  - 해당 컨테이너가 중지, 재시작 되면 "익명 볼륨" 역시 삭제된다!
    - 데이터 유지(persist) 문제가 여전히 존재함
- 명명 볼륨
  - 컨테이너와 이미지와 같이 볼륨에도 이름을 명시할 수 있다.
    - `docker run ~~ -v 볼륨이름:볼륨저장위치 이미지이름`와 같이 컨테이너를 실행할때 볼륨의 이름을 명명할 수 있다.
      - 볼륨이름을 지정하지 않으면 익명 볼륨이 생성된다.
    - 위 작업으로 명명 볼륨이 생성되었으며, 컨테이너를 실행할때 볼륨을 지정하면 해당 볼륨이 매핑된다.
    - 익명 볼륨과는 다르게 이름을 갖는 명명 볼륨은 매핑 컨테이너가 삭제되어도 같이 삭제되지 않는다!
- 볼륨 삭제
  - `docker volume rm 볼륨이름` 이나 `docker volume prune`을 통해 쌓인 익명 볼륨을 삭제할 수 있다.

#### 바인드 마운트(Bind Mounts)

- 시점 A에 생성한 이미지로 컨테이너를 실행 중이다.
  
  - 이때 페이지에 수정을 하면 해당 사항이 반영될까? -> 이미지는 시점 A의 "스냅샷"으로 해당 시점 이후 발생한 수정사항은 반영되지 않는다.
  
  - 만약 반영하기 위해선, 새로운 이미지를 빌드하고 해당 이미지로 새로운 컨테이너를 실행시켜야 한다.

- 새로운 수정사항을 반영하기 위해 새로운 이미지 빌드 - 컨테이너 실행이 아닌, 호스트 머신에 저장된 데이터(소스코드)와 컨테이너를 묶어(Bind) 반영한다(Mounts)
  
  - `docker run ~~ -v "로컬저장위치:볼륨저장위치" 이미지이름`로 바인드 마운트를 생성 가능하다.

### Finding/ Creating Images

1. Docker hub에 pre-built인 **공식 이미지**를 가져와 사용하기
   
   ```cmd
   docker run node
   ```
   
   Docker hub에서 자동으로 node image를 불러옴
   
   ![](C:\Users\seho2\AppData\Roaming\marktext\images\2022-12-13-17-09-03-image.png)
   
   동일한 Image `node`로 다른 2개의 컨테이너(`quirky_burnell`,`wizardly_torvalds`)생성

2. 사용자가 필요한 조건의 custom image 생성하기
   
   1. 애플리케이션 생성
   
   2. Dockerfile 생성
      
      ```dockerfile
      FROM node # 베이스 이미지 파일 설정 
      
      WORKDIR /app # working directory 설정 
      
      COPY . /app # workdir의 모든 파일을 /app 로 복사한다.
      
      RUN npm install # 이미지 생성시 실행
      
      EXPOSE 80 # 컨테이너 내부에서 수신 대기중인 포트를 외부로 알린다.
      
      CMD ["node", "server.js"] # 이미지를 기반으로 컨테이너 시작시 실행
      ```
   
   3. `docker -p 3000:80 dockerId` 와 같은 명령어로 컨테이너 실행
      
      - `EXPOSE`에서 포트 번호를 80으로 "명시"했는데, 이는 문서화에만 그친다. 결국 노출되는 포트는 명령어에서 지정된 포트로 노출된다.

#### Image는 readonly

- 수정사항이 생겨 애플리케이션에 반영하면 이전에 생성된 image는 어떤 상태일까?
  - 수정사항이 반영되지 않는다! 새로운 image를 생성후 다시 빌드해야한다.

### 이미지 레이어

#### 레이어 기반 아키텍쳐

- Dockerfile의 1줄의 명령어는 1개의 레이어로 치환된다.
  
  - 모든 각각의 레이어는 캐시로 저장된다.

- 애플리케이션 또는 환경의 변경사항이 없다면, 새로운 빌드에 이전에 캐싱된 레이어를 사용한다.
  
  - 레이어 A에서 변경사항이 발견된다면, **그 이후의 모든 레이어는 새롭게 실행**된다.(이전 캐싱 레이어 사용X)

- 도커는 새로운 빌드가 필요한 이미지만 부분적으로 생산한다.
  
  - 이미지 생성 시간의 효율적 관리

- 이미지 기반 레이어를 이해했다면 이전의 Dockerfile 예시를 최적화할 수 있다.
  
  ```dockerfile
  FROM node
  
  WORKDIR /app
  # 우선 npm install을 위한 package.json을 미리 COPY
  COPY package.json /app
  # 필요 환경 실행
  RUN npm install
  
  COPY . /app
  
  EXPOSE 80
  
  CMD ["node", "server.js"] 
  ```
  
  - 이전에는 환경 변동이 없어도 코드 변동이 감지되면 무조건 재실행되기 때문에 불필요한 작업이었다. 
  - 하지만 미리 환경 변동을 확인함으로 최적화가 가능하다.

### 이미지 & 컨테이너 관리

- 이미지 태그, 리스트, 분석, 삭제

- 컨테이너 명명, 확인, 리스트, 삭제

- `docker --help`로 명령어 확인 가능

#### Detached & Attached 컨테이너

- Attached : 터미널과 실행중인 컨테이너를 연결. 컨테이너의 로그를 실시간 확인 가능. 실행 default
  
  > `docker attach container_name`으로 분리된 컨테이너와 연결할 수 있다.

- Dettached : 터미널을 실행 후 터미널과 분리한다. 
  
  > `docker run -d ~~` 로 컨테이너를 실행후 터미널과 분리 가능하다.

- `docker logs container_name`으로 각 컨테이너의 log를 확인 가능하다!

#### 인터렉티브 모드 실행

- `docker run -it container_id` 로 인터렉티브 모드가 실행 가능하다.
  
  - help를 통해 옵션값을 찾아보자.

- `docker start -a -i container_name`로 이전에 생성한 컨테이너를 attached로 interactive로 실행 가능하다.

#### 이미지 & 컨테이너 삭제하기

- 실행중이지 않은 이전에 생성된 컨테이너를 삭제해보자.
  
  - `docker rm container_name` : 컨테이너를 삭제한다. 실행중인건 끄고 삭제해야함 
  
  - 중지된 컨테이너 자동 제거하기
    
    - `docker run -p port1:port2 -d --rm image_id` : image_id를 detached로 실행하며, 실행 컨테이너가 중지하면 자동으로 제거한다.

- 실행중인 컨테이너가 없는 이미지를 삭제해보자
  
  - `docker images` : 이미지 목록 확인
  
  - `docker rmi image_id` : 이미지 삭제하기
    
    - 만약 해당 이미지로 만들어진 컨테이너가 있다면 연관 컨테이너 삭제 or 강제 삭제해야한다.
  
  - `docker image prune` : 컨테이너로 사용되지 않는 이미지를 삭제(prune : 가지치기) 한다.

#### 컨테이너에/로부터 파일 복사하기

- 컨테이너에  붙여넣기 
  
  - `docker cp from/. container_name:/to`

- 컨테이너로부터 붙여넣기
  
  - `docker cp from/. container_name:/to`

- 근데 컨테이너 크기가 엄청 큰거아니면 자그마한 수정사항에도 다시 빌드해서 해야할듯;

#### 컨테이너와 이미지에 태그, 이름 지정

- 컨테이너에 이름 지정
  
  - `docker run -p port:port --name STRING image_id` : STRING을 이름으로 하는 컨테이너 생성

- 이미지에 태그 지정
  
  - 베이스이미지에 태그를 추가하여 특정 버전, 구성을 선택하여 사용할 수 있다.
  
  - `FROM imageName:imageTag`
  
  - 또는 내가 원하는 태그를 추가하여 새로운 이미지를 생성할 수 있다.

---

- 레퍼런스

> [Udemy - Docker & Kubernetes : 실전 가이드](https://www.udemy.com/course/docker-kubernetes-2022/)
